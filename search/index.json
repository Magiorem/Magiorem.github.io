[{"content":"DOM模型 DOM简介 DOM，全称Document Object Model，中文翻译为文档对象模型。DOM属于Web API的一部分。Web API中定义了非常多的对象，通过这些对象可以完成对网页的各种操作（添加删除元素、发送请求、操作浏览器等）。\nDOM中的D意为Document，即文档。所谓文档就是指整个网页，换言之，DOM是用来操作网页的。O意为Object，即对象。DOM将网页中的每一部分内容都转换为了对象，div有div的对象，input有input的对象，甚至一段文本，一段注释也有其所对应的对象。转换为对象干什么？还记得面向对象吗？转换对象以后，我们就可以以面向对象的方式去操作网页，想要操作哪个元素就获取哪个元素的对象，然后通过调用其方法或属性完成各种操作。M意为Model，即模型。模型用来表示对象之间的关系，也就是父子元素、祖先后代、兄弟元素等，明确关系后我们便可以通过任意一个对象去获取其他的对象。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;My Title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;A Heading\u0026lt;/h1\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;Link Text\u0026lt;/a\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; HelloWorld document对象代表的是整个网页，通过document可以找到网页中任意对象\n\u0026lt;button id=\u0026#34;btn\u0026#34;\u0026gt;点我一下\u0026lt;/button\u0026gt; \u0026lt;script\u0026gt; const btn = document.getElementById(\u0026#34;btn\u0026#34;) console.log(btn) btn.innerText = \u0026#34;Click Me\u0026#34; \u0026lt;/script\u0026gt; document对象 document对象表示的是整个网页，它的对象的原型链是：\nHTMLDocument -\u0026gt; Document -\u0026gt; Node -\u0026gt; EventTarget -\u0026gt; Object.prototype -\u0026gt; null\n凡是在原型链上存在的对象的属性和方法都可以通过Document来调用\ndocument的部分属性：\ndocument.documentElement html根元素\ndocument.head head元素\ndocument.title title元素\ndocument.body body元素\ndocument.links 获取页面中所有的超链接\n元素节点对象（element） 在网页中，每一个标签都是一个元素节点\n如何获取元素节点对象？\n通过document获取已有的元素节点 通过document创建新的元素节点 获取元素节点 document.getElementById()\n根据id获取一个元素节点对象 document.getElementsByClassName()\n根据元素class属性获取一组元素节点对象 它获取到的是一个类数组，可以查看长度、索引查看，但不能使用数组的方法 该方法返回的结果是一个实时更新的集合，当网页中添加新的元素时，集合也会实时更新 \u0026lt;span class=\u0026#34;s1\u0026#34;\u0026gt;我是sapn\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;s1\u0026#34;\u0026gt;我是sapn\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;s1\u0026#34;\u0026gt;我是sapn\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;s1\u0026#34;\u0026gt;我是sapn\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;s1\u0026#34;\u0026gt;我是sapn\u0026lt;/span\u0026gt; \u0026lt;script\u0026gt; let spans = document.getElementsByClassName(\u0026#34;s1\u0026#34;) console.log(spans) \u0026lt;/script\u0026gt; document.getElementsByTagName()\n根据标签名获取一组元素节点对象 参数添加为*，会把页面中所有的标签全都拿到 \u0026lt;div\u0026gt;我是div\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;我是div\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;我是div\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;我是div\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;我是div\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;我是div\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; let divs = document.getElementsByTagName(\u0026#34;div\u0026#34;) console.log(divs) \u0026lt;/script\u0026gt; document.getElementsByName()\n根据name属性来获取元素节点对象 主要用于表单项，表单项有name属性 \u0026lt;form\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;gender\u0026#34; value=\u0026#34;男\u0026#34;\u0026gt;男 \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;gender\u0026#34; value=\u0026#34;女\u0026#34;\u0026gt;女 \u0026lt;/form\u0026gt; \u0026lt;script\u0026gt; const genderInput = document.getElementsByName(\u0026#34;gender\u0026#34;) console.log(genderInput); \u0026lt;/script\u0026gt; document.querySelectorAll()\n根据选择器去页面中查询元素 它会返回一个类数组，但是不会实时更新（缺点） \u0026lt;button id=\u0026#34;btn\u0026#34;\u0026gt;点我\u0026lt;/button\u0026gt; \u0026lt;form\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;gender\u0026#34; value=\u0026#34;男\u0026#34;\u0026gt;男 \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;gender\u0026#34; value=\u0026#34;女\u0026#34;\u0026gt;女 \u0026lt;/form\u0026gt; \u0026lt;div class=\u0026#34;s1\u0026#34;\u0026gt;你好\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;s1\u0026#34;\u0026gt;你好\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;你好\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;你好\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;你好\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; let a = document.querySelectorAll(\u0026#34;div\u0026#34;) let b = document.querySelectorAll(\u0026#34;.s1\u0026#34;) let c = document.querySelectorAll(\u0026#34;#btn\u0026#34;) console.log(a); console.log(b); console.log(c) \u0026lt;/script\u0026gt; document.querySelector()\n根据选择器去页面中查询第一个符合条件的元素 创建元素节点 document.createElement()\n根据标签名创建一个元素节点对象 元素节点的属性和方法 div元素的原型链\nHTMLDivElement -\u0026gt; HTMLElement -\u0026gt; Element -\u0026gt; Node -\u0026gt;……\n在元素节点中也可以获取其他节点，就在当前元素节点的内部去查找\n\u0026lt;div id=\u0026#34;box1\u0026#34;\u0026gt; 你好 \u0026lt;span class=\u0026#34;s1\u0026#34;\u0026gt;我是s1\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;s1\u0026#34;\u0026gt;我是s1\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;span class=\u0026#34;s1\u0026#34;\u0026gt;我是s1\u0026lt;/span\u0026gt; \u0026lt;script\u0026gt; let box1 = document.getElementById(\u0026#34;box1\u0026#34;) let spans = box1.getElementsByTagName(\u0026#34;span\u0026#34;) console.log(spans); \u0026lt;/script\u0026gt; element.childNodes()\n获取当前元素的子节点 \u0026lt;div id=\u0026#34;box1\u0026#34;\u0026gt; 你好 \u0026lt;span class=\u0026#34;s1\u0026#34;\u0026gt;我是s1\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;s1\u0026#34;\u0026gt;我是s1\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;span class=\u0026#34;s1\u0026#34;\u0026gt;我是s1\u0026lt;/span\u0026gt; \u0026lt;script\u0026gt; let cns = box1.childNodes console.log(cns) \u0026lt;/script\u0026gt; 注意：这里span的后面是有空格的，其实空格就是文本，也就是一个文本节点，所以这边的两个span后面都有空格，也就是都有文本节点！\nelement.children\n获取当前元素节点的所有子元素节点 只获取子元素节点，不包括子文本节点等等 \u0026lt;div id=\u0026#34;box1\u0026#34;\u0026gt; 你好 \u0026lt;span class=\u0026#34;s1\u0026#34;\u0026gt;我是s1\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;s1\u0026#34;\u0026gt;我是s1\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;span class=\u0026#34;s1\u0026#34;\u0026gt;我是s1\u0026lt;/span\u0026gt; \u0026lt;script\u0026gt; let children = box1.children console.log(children); \u0026lt;/script\u0026gt; element.firstElementChild\n获取当前元素的第一个子元素 element.lastElementChild\n获取当前元素的最后一个子元素 element.nextElementSibling\n获取当前元素的下一个兄弟元素 element.previousElementSibling\n获取当前元素的前一个兄弟元素 element.parentNode\n获取当前元素的父节点 element.tagName\n获取当前元素的标签名 文本节点 在DOM中，网页中所有的文本内容都是文本节点对象，可以通过元素来获取其中的文本节点对象，但是我们通常不会这样做。\n我们可以直接通过元素来修改其中的文本：\nelement.textContent 获取或修改元素中的文本内容\n获取的是标签中的内容，不会考虑css样式 element.innerText 获取或修改元素中的文本内容\ninnerText获取内容的时候，会考虑css样式 通过innerText去读取css样式，会触发网页的重排（重新计算css样式） 当字符串中有标签的时候，会自动对标签进行转义 element.innerHTML 获取或修改元素中的html代码\n可以直接向元素中添加html代码 innerHTML插入内容的时候，有被xss注入的风险 属性节点 在DOM中，属性节点也是一个对象，通常不需要获取对象而是直接通过元素就可以完成对其的各种操作。\n元素.属性名 （注意：class属性需要用className来获取）\n读取一个布尔值时，会返回true或false 元素.属性名 = 属性值 来修改属性 元素.getAttribute(属性名) 读取属性名\n元素.setAttribute(属性名, 属性值) 设置属性名\n事件（event） 事件是用户和页面之间发生交互的行为，比如：点击按钮，鼠标移动，双击按钮，敲击键盘，松开键盘……\n我们可以通过为事件绑定响应函数（回调函数），来完成和用户之间的交互\n可以直接在元素的属性中设置\n可以通过为元素指定属性设置回调函数的形式来绑定事件（一个事件只能帮顶一个响应函数）\nconst btn = document.getElementById(\u0026#34;btn\u0026#34;) btn.onclick = function() { alert(\u0026#34;我被点了\u0026#34;) } 元素.addEventListener()\nbtn.addEventListener(\u0026#34;click\u0026#34;, function(){ alert(\u0026#34;哈哈哈\u0026#34;) }) 文档的加载 网页是自上向下加载的，如果js代码编写在网页的上面，js代码在执行的时候，网页还没有加载完毕，这时候会出现无法获取到DOM对象的情况\n如何解决这个问题呢：\n将script标签编写到body的最后 将代码编写到window.onload的回调函数中，这个函数会在网页加载之后执行 将代码编写到DOMContentLoaded的回调函数中，这方法会在当前的对象window加载后就会执行（执行时机更早） 将代码编写到外部的js文件中，然后以defer的形式引入（执行时间更早，早于3 \u0026lt;script defer src=\u0026#34;...\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 元素的修改 网页是自上向下加载的，如果js代码编写在网页的上面，js代码在执行的时候，网页还没有加载完毕，这时候会出现无法获取到DOM对象的情况\n元素.appendChild() 给一个节点添加子节点\n\u0026lt;button id=\u0026#34;btn01\u0026#34;\u0026gt;按钮1\u0026lt;/button\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;ul id=\u0026#34;list\u0026#34;\u0026gt; \u0026lt;li id=\u0026#34;swk\u0026#34;\u0026gt;孙悟空\u0026lt;/li\u0026gt; \u0026lt;li id=\u0026#34;zbj\u0026#34;\u0026gt;猪八戒\u0026lt;/li\u0026gt; \u0026lt;li id=\u0026#34;shs\u0026#34;\u0026gt;沙和尚\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;script\u0026gt; //点击按钮后，向ul中添加一个元素 const list = document.getElementById(\u0026#34;list\u0026#34;) const btn = document.getElementById(\u0026#34;btn01\u0026#34;) btn.onclick = function() { const li = document.createElement(\u0026#34;li\u0026#34;) li.textContent = \u0026#34;唐僧\u0026#34; li.id = \u0026#34;ts\u0026#34; // appendChild()用于给一个节点添加子节点 list.appendChild(li) } \u0026lt;/script\u0026gt; 元素.insertAdjacentElement() 向元素的任意位置添加元素\n两个参数：1.添加的位置\t2.要添加的元素 beforeend 结束标签的前面 afterbegin 开始标签的后面 list.insertAdjacentElement(\u0026#34;beforeend\u0026#34;, li)\t//结束标签之前 元素.replaceWith() 用括号内的元素替换当前元素\nconst list = document.getElementById(\u0026#34;list\u0026#34;) const btn = document.getElementById(\u0026#34;btn01\u0026#34;) btn.onclick = function() { const li = document.createElement(\u0026#34;li\u0026#34;) li.textContent = \u0026#34;蜘蛛精\u0026#34; li.id = \u0026#34;zzj\u0026#34; const swk = document.getElementById(\u0026#34;swk\u0026#34;) swk.replaceWith(li) } 练习-信息增删 \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .outer { width: 400px; margin: 100px auto; text-align: center; } table { width: 400px; border-collapse: collapse; margin-bottom: 20px; } td, th { border: 1px black solid; padding: 10px 0; } form div { margin: 10px 0; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; document.addEventListener(\u0026#34;DOMContentLoaded\u0026#34;, function() { function delEmpHandler() { //本练习中的超链接，不希望发生跳转，但是超链接必定会跳转 //跳转是超链接的默认行为，点击就会跳转 //我们可以用事件取消默认行为来阻止超链接的跳转 //使用return false来取消默认行为，只在xxx.xxx = function(){}中有用 //javascript:;这是让href不跳转，转而去执行js代码，而这个js代码是什么都不干 //this是当前点击的超链接，父节点是td，再父节点是tr const tr = this.parentNode.parentNode const empName = tr.getElementsByTagName(\u0026#34;td\u0026#34;)[0].textContent let flag = confirm(\u0026#34;确认删除[\u0026#34;+empName+\u0026#34;]吗？\u0026#34;) if (flag) { tr.remove() } } // 点击删除后，会把对应的记录删除 //获得所有的超链接 const links = document.links for (let i=0; i\u0026lt;links.length; i++) { links[i].onclick = delEmpHandler } const tbody = document.querySelector(\u0026#34;tbody\u0026#34;) const btn = document.getElementById(\u0026#34;btn\u0026#34;) btn.onclick = function() { //获取用户输入数据 const name = document.getElementById(\u0026#34;name\u0026#34;).value const email = document.getElementById(\u0026#34;email\u0026#34;).value const salary = document.getElementById(\u0026#34;salary\u0026#34;).value //将获取到的数据设置为DOM对象 //这种写法，容易被xss攻击 tbody.insertAdjacentHTML( \u0026#34;beforeend\u0026#34;, ` \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;${name}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${email}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${salary}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;javascript:;\u0026#34;\u0026gt;删除\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; ` ) //由于上边的超链接是新添加的，所以它上边并没有绑定单击响应函数，所以新添加的员工无法删除 //解决方式：为新添加的超链接单独绑定响应函数 links[links.length - 1].onclick = delEmpHandler; } }) \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;outer\u0026#34;\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;姓名\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;邮件\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;薪资\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;操作\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;孙悟空\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;swk@123.com\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;10000\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;javascript:;\u0026#34;\u0026gt;删除\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;猪八戒\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;zbj@123.com\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;8000\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;javascript:;\u0026#34;\u0026gt;删除\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;沙和尚\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;shs@123.com\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;1000\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;javascript:;\u0026#34;\u0026gt;删除\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;form action=\u0026#34;#\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label for=\u0026#34;name\u0026#34;\u0026gt;姓名\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;name\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label for=\u0026#34;email\u0026#34;\u0026gt;邮件\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;email\u0026#34; id=\u0026#34;email\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label for=\u0026#34;salary\u0026#34;\u0026gt;薪资\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;number\u0026#34; id=\u0026#34;salary\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button id=\u0026#34;btn\u0026#34;\u0026gt;添加\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; 解决xss注入的风险（避免输入内容和insertHTML关联起来）\nconst tbody = document.querySelector(\u0026#34;tbody\u0026#34;) const btn = document.getElementById(\u0026#34;btn\u0026#34;) btn.onclick = function() { //获取用户输入数据 const name = document.getElementById(\u0026#34;name\u0026#34;).value const email = document.getElementById(\u0026#34;email\u0026#34;).value const salary = document.getElementById(\u0026#34;salary\u0026#34;).value //将获取到的数据设置为DOM对象 const tr = document.createElement(\u0026#34;tr\u0026#34;) const nameTd = document.createElement(\u0026#34;td\u0026#34;) const emailTd = document.createElement(\u0026#34;td\u0026#34;) const salaryTd = document.createElement(\u0026#34;td\u0026#34;) nameTd.textContent = name emailTd.textContent = email salaryTd.textContent = salary tr.appendChild(nameTd) tr.appendChild(emailTd) tr.appendChild(salaryTd) tr.insertAdjacentHTML(\u0026#34;beforeend\u0026#34;, \u0026#39;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;javascript:;\u0026#34;\u0026gt;删除\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026#39;) tbody.appendChild(tr) links[links.length - 1].onclick = delEmpHandler; } 节点的复制cloneNode() 使用cloneNode()方法对节点进行复制，会复制节点的所有特点包括属性只会默认复制当前节点，不会复制节点的子节点（l1.cloneNode()文本节点并没有复制）l1.cloneNode(true) 参数true表示也复制子节点\n\u0026lt;button id=\u0026#34;btn01\u0026#34;\u0026gt;点我\u0026lt;/button\u0026gt; \u0026lt;ul id=\u0026#34;list1\u0026#34;\u0026gt; \u0026lt;li id=\u0026#34;l1\u0026#34;\u0026gt;孙悟空\u0026lt;/li\u0026gt; \u0026lt;li id=\u0026#34;l2\u0026#34;\u0026gt;猪八戒\u0026lt;/li\u0026gt; \u0026lt;li id=\u0026#34;l3\u0026#34;\u0026gt;沙和尚\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;ul id=\u0026#34;list2\u0026#34;\u0026gt; \u0026lt;li\u0026gt;蜘蛛精\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;script\u0026gt; //点击按钮后，将id为l1的元素添加到list2中 const list2 = document.getElementById(\u0026#34;list2\u0026#34;) const l1 = document.getElementById(\u0026#34;l1\u0026#34;) const btn01 = document.getElementById(\u0026#34;btn01\u0026#34;) btn01.onclick = function() { const newL1 = l1.cloneNode(true) //使用cloneNode()方法对节点进行复制，会复制节点的所有特点包括属性 //只会默认复制当前节点，不会复制节点的子节点（l1.cloneNode()文本节点并没有复制） //l1.cloneNode(true) 参数true表示也复制子节点 newL1.id = \u0026#34;newL1\u0026#34; list2.appendChild(newL1) } \u0026lt;/script\u0026gt; 修改css样式 元素.style.样式 = 新样式 会添加内联样式 如果样式中有“-”，则需要将样式改为驼峰命名 如果外部样式加了 !important，那么修改内联样式不会覆盖important的样式 这种方法只能读取到内联样式，如果我设置的是外部的样式，那么是无法读取到的。因此这种方法只会用来设置属性，而不会读取属性 \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .box1 { width: 200px; height: 200px; background-color: #bfa; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button id=\u0026#34;btn01\u0026#34;\u0026gt;点我\u0026lt;/button\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;div class=\u0026#34;box1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; const btn = document.getElementById(\u0026#34;btn01\u0026#34;) const box1 = document.querySelector(\u0026#34;.box1\u0026#34;) btn.onclick = function() { // 添加内联样式 // 如果样式中有-，则需要将样式改为驼峰命名 box1.style.width = \u0026#34;400px\u0026#34; box1.style.height = \u0026#34;400px\u0026#34; box1.style.backgroundColor = \u0026#34;yellow\u0026#34; } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; getComputedStyle() 会返回一个对象，包含了当前元素所有生效的样式 参数：要获取的元素，伪元素 \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .box1 { width: 200px; height: 200px; background-color: #bfa; } .box1::before { content: \u0026#34;hello\u0026#34;; color: red; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button id=\u0026#34;btn01\u0026#34;\u0026gt;点我\u0026lt;/button\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;div class=\u0026#34;box1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; const btn = document.getElementById(\u0026#34;btn01\u0026#34;) const box1 = document.querySelector(\u0026#34;.box1\u0026#34;) btn.onclick = function() { // getComputedStyle() // 会返回一个对象，包含了当前元素所有生效的样式 const styleObj = getComputedStyle(box1) console.log(styleObj) box1.style.width = parseInt(styleObj.width) + 100 + \u0026#34;px\u0026#34; const beforeStyle = getComputedStyle(box1, \u0026#34;::before\u0026#34;) console.log(beforeStyle) } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 其他特殊样式 元素.clientHeight，元素.clientWidth\n元素内部的宽度和高度（包括内容区和内边距） 返回的就是一个数值 元素.offsetHeight，元素.offsetWidth\n返回元素可见框的大小（包括内容区、内边距、边框） 返回的就是一个数值 元素.scrollHeight，元素.scrollWidth\n获取元素滚动区域的大小 元素.offsetParent\n获取元素的定位父元素 定位父元素：离当前元素最近的开启了定位的祖先元素，如果都没开则返回body 元素.offsetTop，元素.offsetLeft\n获取元素相对于其定位父元素的偏移量 \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; #box1 { width: 200px; height: 200px; padding: 50px; margin: 50px; border: 10px red solid; background-color: #bfa; overflow: auto; } #box2 { width: 100px; height: 500px; background-color: blueviolet; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button id=\u0026#34;btn01\u0026#34;\u0026gt;点我\u0026lt;/button\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div id=\u0026#34;box1\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;box2\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; const btn = document.getElementById(\u0026#34;btn01\u0026#34;) const box1 = document.querySelector(\u0026#34;#box1\u0026#34;) const box2 = document.querySelector(\u0026#34;#box2\u0026#34;) btn.onclick = function() { console.log(box1.clientHeight) console.log(box1.clientWidth) console.log(box1.offsetHeight) console.log(box1.offsetWidth) console.log(box1.scrollHeight) console.log(box1.offsetParent) console.log(box2.offsetLeft) } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; classList操作class box1.className获取class名称 \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .box1 { width: 200px; height: 200px; padding: 50px; margin: 50px; background-color: #bfa; overflow: auto; } .box2 { width: 300px; height: 500px; border: 10px red solid; background-color: yellow; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button id=\u0026#34;btn01\u0026#34;\u0026gt;点我\u0026lt;/button\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;box1\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; const btn = document.getElementById(\u0026#34;btn01\u0026#34;) const box1 = document.querySelector(\u0026#34;.box1\u0026#34;) btn.onclick = function() { box1.className += \u0026#34; box2\u0026#34;\t//需要手动添加空格 } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; box1.classList.add(\u0026quot;box2\u0026quot;) btn.onclick = function() { box1.classList.add(\u0026#34;box2\u0026#34;)\t//会自动添加空格 box1.classList.add(\u0026#34;box3\u0026#34;, \u0026#34;box4\u0026#34;, \u0026#34;box5\u0026#34;) } box1.classList.remove(\u0026quot;box2\u0026quot;) 删除某个类 box1.classList.replace(\u0026quot;box1\u0026quot;, \u0026quot;box2\u0026quot;) 替换某个类 box1.classList.contains(\u0026quot;box1\u0026quot;) ","date":"2023-10-30T11:10:10Z","image":"https://magiorem.github.io/p/javascript-dom%E6%93%8D%E4%BD%9C/bc3_hue2adaacafb4d593bceb3af1dbc48d9cb_540478_120x120_fill_box_smart1_3.png","permalink":"https://magiorem.github.io/p/javascript-dom%E6%93%8D%E4%BD%9C/","title":"javaScript-DOM操作"},{"content":"数组中的高阶函数方法 sort() 排序 sort默认会将数组升序排序\n注意：sort默认会按照Unicode编码进行排序，如果直接通过sort对数字进行排序，可能会得到一个不正确的结果！\n参数：可以传递一个回调函数作为参数，通过回调函数来指定排序规则\nconst arr = [\u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;b\u0026#39;] arr.sort() console.log(arr);\t//[\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;] const arr = [2, 3, 1, 9, 0, 4, 5, 8, 10, 11] arr.sort() console.log(arr) // [0, 1, 10, 11, 2, 3, 4, 5, 8, 9] const arr = [2, 3, 1, 9, 0, 4, 5, 8, 10, 11] arr.sort((a, b) =\u0026gt; a - b) console.log(arr)\t// [0, 1, 2, 3, 4, 5, 8, 9, 10, 11] forEach() 遍历 用来遍历数组，它需要一个回调函数作为参数，这个回调函数会被调用多次\n数组中有几个元素，回调函数就调用几次；每次调用，都会把数组中的数据作为参数传递\n回调函数中有三个参数：第一个参数是数组中的元素，第二个参数是索引，第三个参数是当前被遍历的数组\nconst arr = [\u0026#39;孙悟空\u0026#39;, \u0026#39;猪八戒\u0026#39;, \u0026#39;沙和尚\u0026#39;] arr.forEach((element, index, array) =\u0026gt; { console.log(element, index, array) }) filter() 过滤 将数组中符合条件的元素保存到一个新的数组中返回\n需要一个回调函数作为参数，会为每一个元素去调用回调函数，并根据返回值来决定是否将元素添加到新的数组中，非破坏性方法，不会影响原数组\narr = [1, 2, 3, 4, 5, 6, 7, 8] let result = arr.filter((ele) =\u0026gt; { if (ele % 2 === 0) { return true } }) console.log(result)\t// [2, 4, 6, 8] //上述过滤条件可以简写 let result = arr.filter(ele =\u0026gt; ele % 2 == 0) map() 映射 根据当前的数组生成一个新的数组\n需要一个回调函数作为参数，回调函数的返回值会成为新数组中的元素\n非破坏性方法，不影响原数组\narr = [1, 2, 3, 4, 5, 6, 7, 8] let result = arr.map(ele =\u0026gt; ele % 2 == 0) console.log(result) reduce() 合并（简化） 把数组当中的多个值，整合到一起\n第一个数和第二个数整合起来的数与第三个数整合……以此类推\narr = [1, 2, 3, 4, 5, 6, 7, 8] let result = arr.reduce((a, b) =\u0026gt; { console.log(a, b) return a + b }) console.log(result) 函数中的可变参数 arguments arguments是函数中的一个隐含参数，是一个类数组对象（伪数组）和数组相似，可以用索引和for循环，但是他不能用数组的方法。\nfunction fn() { console.log(arguments) console.log(arguments[0]) for (let v of arguments) { console.log(v); } } fn(10, 20, 30, \u0026#34;hello\u0026#34;) 可变参数 在定义函数时可以将参数指定为可变参数。可变参数可以接受任意数量的实参，并将他们统一存储到一个数组中返回\nfunction fn(...num) { console.log(num) return num.reduce((a, b) =\u0026gt; a + b, 0) //0是指定初始值 } let result = fn(2, 9, 20 ,3, 1, 7) console.log(result) call 和 apply 调用函数 调用函数除了通过 函数() 这种形式以外，还可以通过其他方法来调用函数\n比如，我们可以通过 call() 和 apply() 方法来调用函数\n函数.call() 函数.apply()\ncall 和 apply除了可以调用函数外，还可以指定函数中的this！\nfunction fn() { console.log(\u0026#34;函数执行了-\u0026#34;, this); } fn.call() fn.apply() call 和 apply的第一个参数，将会成为函数的this\nfunction fn() { console.log(\u0026#34;函数执行了-\u0026#34;, this); } const obj = { name: \u0026#34;by\u0026#34;, fn } fn.call(obj) fn.apply(obj) fn.call(console) 通过 call 方法调用函数，函数的实参在第一个参数后一个一个列出来\nfunction fn2(a, b) { console.log(\u0026#34;a =\u0026#34;, a, \u0026#34;b =\u0026#34;, b, this) } fn2.call(obj, 1, 2) 通过 apply 方法调用函数，函数的实参需要通过一个数组传递\nfunction fn2(a, b) { console.log(\u0026#34;a =\u0026#34;, a, \u0026#34;b =\u0026#34;, b, this) } fn2.apply(obj, [1, 2]) bind 创建函数 bind() 是函数的方法，可以用来创建一个新的函数\nbind可以为新函数绑定this，不会因为传参变化而变化；bind可以为新函数绑定参数\nfunction fn() { console.log(\u0026#34;函数执行了-\u0026#34;, this); } const obj = {name: \u0026#34;by\u0026#34;} const obj2 = {name: \u0026#34;haha\u0026#34;} const newFn = fn.bind(obj) //绑定后，newFn的this永远是obj newFn() newFn({}) newFn(obj2) function fn(a, b, c) { console.log(\u0026#34;函数执行了-\u0026#34;, this); console.log(a, b, c); } const obj = {name: \u0026#34;by\u0026#34;} const newFn = fn.bind(obj, 10)\t// 10会绑定到a上 newFn(20, 30 ,1, 1, 1)\t// 20和30 开始给b，c赋值 ","date":"2023-10-30T10:10:10Z","image":"https://magiorem.github.io/p/javascript-%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E9%AB%98%E9%98%B6/bc2_hud2bd4ea5532d0982e80619807028b92c_588324_120x120_fill_box_smart1_3.png","permalink":"https://magiorem.github.io/p/javascript-%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E9%AB%98%E9%98%B6/","title":"javaScript-数组方法(高阶)"},{"content":"数组中的初阶方法 数组（Array）数组也是一种复合数据类型，在数组中可以存储多个不同类型的数据；数组中存储的是有序的数据\nconst arr = new Array() const arr2 = [] //数组字面量 数组的类型也是object\nconsole.log(typeof arr)\t//object 数组的遍历（for-of） const arr = [\u0026#34;aa\u0026#34;, \u0026#34;hh\u0026#34;, \u0026#34;123\u0026#34;, \u0026#34;genshin\u0026#34;] for (let i=0; i\u0026lt;arr.length; i++) { console.log(arr[i]); } for-of语句可以遍历可迭代对象（但只可以顺序进行）\nconst arr = [\u0026#34;aa\u0026#34;, \u0026#34;hh\u0026#34;, \u0026#34;123\u0026#34;, \u0026#34;genshin\u0026#34;] for (let value of arr) { console.log(value) } for (let value of \u0026#34;hello\u0026#34;) { console.log(value); } //字符串也是可迭代对象，h,e,l,l,o 数组的方法（非破坏性方法） Array.isArray() 检查一个对象是否是数组 Array.isArray(arr)\nconst arr = [\u0026#34;aa\u0026#34;, \u0026#34;hh\u0026#34;, \u0026#34;123\u0026#34;, \u0026#34;genshin\u0026#34;] console.log(Array.isArray(arr));\t//true at() 根据索引获得元素（可以负索引） const arr = [\u0026#34;aa\u0026#34;, \u0026#34;hh\u0026#34;, \u0026#34;123\u0026#34;, \u0026#34;genshin\u0026#34;] console.log(arr.at(-1))\t//genshin concat() 连接两个数组 const arr = [\u0026#34;aa\u0026#34;, \u0026#34;hh\u0026#34;, \u0026#34;123\u0026#34;, \u0026#34;genshin\u0026#34;] const arr2 = [1, 2] console.log(arr.concat(arr2));\t//[\u0026#39;aa\u0026#39;, \u0026#39;hh\u0026#39;, \u0026#39;123\u0026#39;, \u0026#39;genshin\u0026#39;, 1, 2] //arr不会有任何变化（非破坏性） indexOf() 第一次出现的索引 lastIndexOf()可以查最后一次出现的位置如果没有则返回-1\nconst arr = [\u0026#34;aa\u0026#34;, \u0026#34;hh\u0026#34;, \u0026#34;123\u0026#34;, \u0026#34;genshin\u0026#34;] console.log(arr.indexOf(\u0026#34;genshin\u0026#34;)); join() 数组转字符串 参数可以指定一个字符串作为连接符\nconst arr = [\u0026#34;aa\u0026#34;, \u0026#34;hh\u0026#34;, \u0026#34;123\u0026#34;, \u0026#34;genshin\u0026#34;] console.log(arr.join()); //aa,hh,123,genshin console.log(arr.join(\u0026#34;-\u0026#34;));//aa-hh-123-genshin slice() 截取数组 前闭后开第二个参数可以不写，不写则截取到最后\nconst arr = [\u0026#34;aa\u0026#34;, \u0026#34;hh\u0026#34;, \u0026#34;123\u0026#34;, \u0026#34;genshin\u0026#34;] const result = arr.slice(0, 2) console.log(result)\t//[\u0026#39;aa\u0026#39;, \u0026#39;hh\u0026#39;] console.log(arr.slice(1));\t//[\u0026#39;hh\u0026#39;, \u0026#39;123\u0026#39;, \u0026#39;genshin\u0026#39;] arr.slice()\t//可以获得一个一模一样的数组，浅复制 数组的复制 简单的变量赋值不是复制！！没有产生新的对象！\nconst arr = [\u0026#34;aa\u0026#34;, \u0026#34;hh\u0026#34;, \u0026#34;123\u0026#34;, \u0026#34;genshin\u0026#34;] const arr2 = arr arr2[1] = \u0026#34;new\u0026#34; console.log(arr) // [\u0026#39;aa\u0026#39;, \u0026#39;new\u0026#39;, \u0026#39;123\u0026#39;, \u0026#39;genshin\u0026#39;] console.log(arr2 === arr) //true arr和arr2都指向同一个地址，同一个对象\nslice() 浅复制 slice不加参数，可以对数组进行一次浅复制，会产生一个新的数组对象\nconst arr = [\u0026#34;aa\u0026#34;, \u0026#34;hh\u0026#34;, \u0026#34;123\u0026#34;, \u0026#34;genshin\u0026#34;] const arr2 = arr.slice() arr2[1] = \u0026#34;new\u0026#34; console.log(arr) // [\u0026#39;aa\u0026#39;, \u0026#39;hh\u0026#39;, \u0026#39;123\u0026#39;, \u0026#39;genshin\u0026#39;] console.log(arr2 === arr) //false 浅拷贝和深拷贝 浅拷贝：通常对象的拷贝都是浅拷贝，浅拷贝顾名思义，只对对象的浅层进行复制（只复制一层），如果对象中存储的数据是原始值，那么拷贝的深浅都不重要。浅拷贝只会对对象本身进行复制，不会对对象中的属性或其他东西进行复制\nconst arr = [{name: \u0026#34;by\u0026#34;}, {name: \u0026#34;haha\u0026#34;}] const arr2 = arr.slice() console.log(arr === arr2)\t//false console.log(arr[0] === arr2[0])\t//true !深拷贝：不仅复制对象本身，还复制对象中的属性和元素；因为性能问题，通常情况下我们不用深拷贝\nconst arr3 = structuredClone(arr) \u0026hellip; 展开运算符 [\u0026hellip;arr] 展开运算符可以把一个数组的元素展开到另一个数组中或者作为函数的参数传递（这是一种浅复制）\nconst arr = [\u0026#34;哈哈\u0026#34;, \u0026#34;嘻嘻\u0026#34;, \u0026#34;啦啦\u0026#34;] const arr2 = [...arr] console.log(arr === arr2) //false const arr3 = [\u0026#34;耶耶\u0026#34;, ...arr, \u0026#34;呜呜\u0026#34;] function sum(a, b, c) { return a + b + c } const arr = [1, 2, 3] let result = sum(...arr) console.log(result)\t//6 Object.assign()对象的复制 Object.assign(目标对象，被复制的对象)将被复制对象中的属性复制给目标对象，并将目标对象返回\nconst obj = {name: \u0026#39;by\u0026#39;, age: 18} const obj2 = Object.assign({}, obj) console.log(obj2 === obj) //false const obj3 = {address: \u0026#39;苏州大学\u0026#39;} Object.assign(obj3, obj) console.log(obj3) //{address: \u0026#39;苏州大学\u0026#39;, name: \u0026#39;by\u0026#39;, age: 18} const obj4 = {...obj}\t//也可以使用展开运算符来浅复制 console.log(obj4) 数组的方法（破坏性方法） push() pop() push()：向数组的末尾添加一个或多个元素，并且返回数组长度pop()：删除并返回最后一个元素\nunshift() shift() unshift()：向数组开头添加一个或多个元素，并返回新的长度shift()：删除并返回第一个元素\nsplice() 可以删除、添加、插入、替换\n//删除 let arr = [\u0026#34;孙悟空\u0026#34;, \u0026#34;猪八戒\u0026#34;, \u0026#34;沙和尚\u0026#34;, \u0026#34;唐僧\u0026#34;] arr.splice(1, 2) //删除的起始位置，删除的数量 console.log(arr)\t// [\u0026#39;孙悟空\u0026#39;, \u0026#39;唐僧\u0026#39;] //替换 let arr = [\u0026#34;孙悟空\u0026#34;, \u0026#34;猪八戒\u0026#34;, \u0026#34;沙和尚\u0026#34;, \u0026#34;唐僧\u0026#34;] arr.splice(1, 2, \u0026#34;牛魔王\u0026#34;, \u0026#34;红孩儿\u0026#34;) //删除的起始位置，删除的数量，插入的元素（在起始位置插入） console.log(arr) // [\u0026#39;孙悟空\u0026#39;, \u0026#39;牛魔王\u0026#39;, \u0026#39;红孩儿\u0026#39;, \u0026#39;唐僧\u0026#39;] //添加 let arr = [\u0026#34;孙悟空\u0026#34;, \u0026#34;猪八戒\u0026#34;, \u0026#34;沙和尚\u0026#34;, \u0026#34;唐僧\u0026#34;] arr.splice(1, 0, \u0026#34;牛魔王\u0026#34;, \u0026#34;红孩儿\u0026#34;) console.log(arr)//[\u0026#39;孙悟空\u0026#39;, \u0026#39;牛魔王\u0026#39;, \u0026#39;红孩儿\u0026#39;, \u0026#39;猪八戒\u0026#39;, \u0026#39;沙和尚\u0026#39;, \u0026#39;唐僧\u0026#39;] 数组去重-练习 const arr = [1, 2, 1, 3, 2, 2, 4, 5, 5, 6, 7] for (let i=0; i\u0026lt;arr.length; i++) { const index = arr.indexOf(arr[i], i+1) if (index !== -1) { arr.splice(index, 1) i-- } } console.log(arr) const arr = [1, 2, 1, 3, 2, 2, 4, 5, 5, 6, 7] const newArr = [] for (let ele of arr) { if (newArr.indexOf(ele) === -1) { newArr.push(ele) } } console.log(newArr) ","date":"2023-10-30T10:09:10Z","image":"https://magiorem.github.io/p/javascript-%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E5%88%9D%E9%98%B6/bc1_huda406074d04e3965ca8b541c55a73390_513533_120x120_fill_box_smart1_3.png","permalink":"https://magiorem.github.io/p/javascript-%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E5%88%9D%E9%98%B6/","title":"javaScript-数组方法(初阶)"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating. — Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://magiorem.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://magiorem.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Hugo ships with several Built-in Shortcodes for rich content, along with a Privacy Config and a set of Simple Shortcodes that enable static and no-JS versions of various social media embeds.\nYouTube Privacy Enhanced Shortcode Twitter Simple Shortcode Vimeo Simple Shortcode bilibilibi Shortcode Gist Shortcode Gitlab Snippets Shortcode Quote Shortcode Stack adds a quote shortcode. For example:\nLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― A famous person, The book they wrote Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― Anonymous book Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― Some book Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― Somebody","date":"2019-03-10T00:00:00Z","permalink":"https://magiorem.github.io/p/rich-content/","title":"Rich Content"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://magiorem.github.io/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu958d513eeefe5556a31d065479ecc5ac_14205_120x120_fill_q75_box_smart1.jpg","permalink":"https://magiorem.github.io/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","date":"2019-03-08T00:00:00Z","permalink":"https://magiorem.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n.emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; }","date":"2019-03-05T00:00:00Z","image":"https://magiorem.github.io/the-creative-exchange-d2zvqp3fpro-unsplash.jpg","permalink":"https://magiorem.github.io/p/emoji-support/","title":"Emoji Support"},{"content":"","date":"2019-03-05T00:00:00Z","image":"https://magiorem.github.io/the-creative-exchange-d2zvqp3fpro-unsplash.jpg","permalink":"https://magiorem.github.io/p/emoji-support/","title":"Emoji Support"}]